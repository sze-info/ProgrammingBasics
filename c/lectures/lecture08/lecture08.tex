\documentclass[usenames,dvipsnames,aspectratio=169]{beamer}
\usepackage{../common/prgBasics}

\title[Lecture 8.]{Programming basics}
\subtitle{(GKNB\_INTA023)}

\begin{document}

%1
\begin{frame}[plain]
  \titlepage
\end{frame}

%2
\begin{frame}{Function to swap the values of variables in the caller}
  Goal:
  \begin{itemize}
    \item[] Write a function to swap the values of two variables! The effect must be visible in the caller!
  \end{itemize}
  Problem:
  \begin{itemize}
    \item Actual parameters are passed by value (the formal parameters are copies of the actual parameters and our goal is to swap the values of the \emph{original} variables and not their \emph{copies}).
    \item A function may have at most one return value.
  \end{itemize}
  \begin{exampleblock}{\textattachfile{swap1.c}{swap1.c}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={1-5}]{swap1.c}
    \vspace{-.3cm}
  \end{exampleblock}
\end{frame}

%3
\begin{frame}[fragile]{Function to swap the values of variables in the caller}
  \begin{alertblock}{\textattachfile{swap1.c}{swap1.c} -- First attempt, \texttt{swap1}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={7-11},firstnumber=7]{swap1.c}
    \vspace{-.3cm}
  \end{alertblock}
  \begin{exampleblock}{\textattachfile{swap1.c}{swap1.c} -- First lines of \texttt{main}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={26-29},firstnumber=26]{swap1.c}
    \vspace{-.3cm}
  \end{exampleblock}
  \begin{block}{First lines of the output}
    \scriptsize
    \begin{verbatim}
Original values:  a = 1, b = 2
After swap1:      a = 1, b = 2
\end{verbatim}
  \end{block}
\end{frame}

%4
\begin{frame}[fragile]{Function to swap the values of variables in the caller}
  \begin{alertblock}{\textattachfile{swap1.c}{swap1.c} -- Second attempt, \texttt{swap2}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={13-18},firstnumber=13]{swap1.c}
    \vspace{-.3cm}
  \end{alertblock}
  \begin{exampleblock}{\textattachfile{swap1.c}{swap1.c} -- Some lines of \texttt{main}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={30-31},firstnumber=30]{swap1.c}
    \vspace{-.3cm}
  \end{exampleblock}
  \begin{block}{Corresponding line of output}
    \scriptsize
    \begin{verbatim}
After swap2:      a = 2, b = 1
\end{verbatim}
  \end{block}
\end{frame}

%5
\begin{frame}[fragile]{Function to swap the values of variables in the caller}
  \begin{exampleblock}{\textattachfile{swap1.c}{swap1.c} -- Third attempt, \texttt{swap3}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={20-24},firstnumber=20]{swap1.c}
    \vspace{-.3cm}
  \end{exampleblock}
  \begin{exampleblock}{\textattachfile{swap1.c}{swap1.c} -- Some lines of \texttt{main}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={32-34},firstnumber=32]{swap1.c}
    \vspace{-.3cm}
  \end{exampleblock}
  \begin{block}{A snippet of output}
    \scriptsize
    \begin{verbatim}
After swap2:		  a = 2, b = 1
After swap3:		  a = 1, b = 2
\end{verbatim}
  \end{block}
\end{frame}

%6
\begin{frame}{Function to swap the values of variables in the caller}
  \begin{exampleblock}{\textattachfile{swap2.c}{swap2.c} -- Swapping functions}
    \scriptsize
    \lstinputlisting[style=c,linerange={3-19},firstnumber=3]{swap2.c}
  \end{exampleblock}
\end{frame}

%7
\begin{frame}{Function to swap the values of variables in the caller}
  \begin{exampleblock}{\textattachfile{swap2.c}{swap2.c} -- The \texttt{main} function}
    \footnotesize
    \lstinputlisting[style=c,linerange={21-32},firstnumber=21]{swap2.c}
  \end{exampleblock}
\end{frame}

%8
\begin{frame}[fragile]{Function to swap the values of variables in the caller}
  \begin{block}{Output}
    \footnotesize
    \begin{verbatim}
main: address of 'a': 0x7ffd85320ef0, address of 'b': 0x7ffd85320ef4
main: value of 'a': 1, value of 'b': 2
swap1: address of 'a': 0x7ffd85320ecc, address of 'b': 0x7ffd85320ec8
swap1: value of 'a': 1, value of 'b': 2
main, after calling swap1: value of 'a': 1, value of 'b': 2
swap3: address of 'a': 0x7ffd85320ec8, address of 'b': 0x7ffd85320ec0
swap3: value of 'a': 0x7ffd85320ef0, value of 'b': 0x7ffd85320ef4
swap3: value@address 'a': 1, value@address 'b': 2
main, after calling swap3: value of 'a': 2, value of 'b': 1
\end{verbatim}
  \end{block}
\end{frame}

%9
\begin{frame}{Drawing rectangles}
  \scriptsize
  \begin{exampleblock}{\textattachfile{rectangle2.c}{rectangle2.c} \texttt{readTLX}: Do you want to enter further rectangles? If yes, what is the X coord. of the TL corner?}
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={39-58},firstnumber=39]{rectangle2.c}
    \vspace{-.3cm}
  \end{exampleblock}
\end{frame}

%10
\begin{frame}{Drawing rectangles}
  \begin{exampleblock}{\textattachfile{rectangle2.c}{rectangle2.c}}
    \tiny
    \lstinputlisting[style=c,linerange={60-78},firstnumber=60]{rectangle2.c}
  \end{exampleblock}
\end{frame}

%11
\begin{frame}{Pointers}
  Further information regarding pointers
  \begin{itemize}
    \item Example: \textattachfile{pointers.c}{pointers.c}
    \item \kiemel{Watch out!} \texttt{i} is an \texttt{int}, but \texttt{pi1} and \texttt{pi2} are pointers to \texttt{int}s!
    \item Any number of white spaces can be placed on both sides of \kiemel{*}
    \item A pointer can be initialized, too
  \end{itemize}
  \begin{exampleblock}{}
    \lstinputlisting[style=c,linerange={4-7},firstnumber=4]{pointers.c}
  \end{exampleblock}
\end{frame}

%12
\begin{frame}{Pointers}
  \begin{itemize}
    \item If an object does not have a memory location/address, even operator \kiemel{\&} cannot determine it
  \end{itemize}
  \begin{alertblock}{}
    \small
    \lstinputlisting[style=c,linerange={8-10},firstnumber=8]{pointers.c}
  \end{alertblock}
  \begin{itemize}
    \item In general, assignments can be carried out with pointers of the same type
  \end{itemize}
  \begin{alertblock}{}
    \small
    \lstinputlisting[style=c,linerange={11-12},firstnumber=11]{pointers.c}
  \end{alertblock}
\end{frame}

%13
\begin{frame}{Pointers}
  \begin{itemize}
    \small
    \item Exception: any pointers can be assigned to a \texttt{void*} pointer \\($\approx$ dropping type information)
  \end{itemize}
  \begin{exampleblock}{}
    \small
    \lstinputlisting[style=c,linerange={13-14},firstnumber=13]{pointers.c}
  \end{exampleblock}
  \begin{itemize}
    \small
    \item It can be done in the opposite direction, but the type of data at the specified address may be incompatible
  \end{itemize}
  \begin{alertblock}{}
    \footnotesize
    \lstinputlisting[style=c,linerange={15-15},firstnumber=15]{pointers.c}
  \end{alertblock}
\end{frame}

%14
\begin{frame}{Pointers}
  \begin{itemize}
    \item \texttt{NULL} is a special address: no data is stored there
    \item It indicates an error or lack of something
    \item Can be assigned to any type of pointers
  \end{itemize}
  \begin{exampleblock}{}
    \footnotesize
    \lstinputlisting[style=c,linerange={16-16},firstnumber=16]{pointers.c}
  \end{exampleblock}
\end{frame}

%15
\begin{frame}{Date management}
  Practical problem:
  \begin{itemize}
    \item[] the structures are usually big, parameter passing needs too much time
  \end{itemize}
  Solution:
  \begin{itemize}
    \item pass the \emph{address} of the structure!
    \item \kiemel{Danger!} If the \emph{called} fn. modifies the parameter, that affects the variable in the \emph{caller}, too!
    \item To avoid the unintended modifications of variables in the \emph{called} fn.: modifier \kiemel{\texttt{const}} makes the parameter read-only (it can be used with other types as well)
    \item Indirection + member access: with operator \kiemel{\texttt{->}}, eg. \texttt{(*d).day} $\equiv$ \texttt{d->day}
  \end{itemize}
\end{frame}

%16
\begin{frame}{Date management}
  \begin{exampleblock}{\textattachfile{calendar2.c}{calendar2.c}}
    \footnotesize
    \lstinputlisting[style=c,linerange={23-37},firstnumber=23]{calendar2.c}
  \end{exampleblock}
\end{frame}

%17
\begin{frame}{Date management}
  \begin{exampleblock}{\textattachfile{calendar2.c}{calendar2.c}}
    \footnotesize
    \lstinputlisting[style=c,linerange={64-78},firstnumber=64]{calendar2.c}
  \end{exampleblock}
\end{frame}

%18
\begin{frame}{Bubble sort}
  \begin{exampleblock}{\textattachfile{bubble2.c}{bubble2.c}}
    \small
    \lstinputlisting[style=c,linerange={1-13},firstnumber=1]{bubble2.c}
  \end{exampleblock}
\end{frame}

%19
\begin{frame}[fragile]{Bubble sort}
  \begin{exampleblock}{\textattachfile{bubble2.c}{bubble2.c}}
    \footnotesize
    \lstinputlisting[style=c,linerange={15-25},firstnumber=15]{bubble2.c}
  \end{exampleblock}
  \begin{block}{Output}
    \footnotesize
    \begin{verbatim}
After sorting:
-4      3      3      4      7     12     54     56
\end{verbatim}
  \end{block}
\end{frame}

%20
\begin{frame}{Pointers and arrays}
  Please consider that
  \begin{itemize}
    \item The size of the array is \emph{not always needed} to be passed, but the function needs to know the number of elements to sort
    \item The \emph{called} function has \kiemel{modified} the array!
  \end{itemize}
  Explanation:
  \begin{itemize}
    \item Arrays are usually big $\to$ \kiemel{always} a pointer to the array is passed!
    \item The name of the array is a \emph{constant pointer} (the pointer cannot be modified, but the data where it points to can be modified),
eg.\\ \texttt{int a[]} $\equiv$ \texttt{int* const a}
    \item The content of the array can be made read-only: \\ \texttt{const int* const a} $\equiv$ \texttt{const int a[]}
  \end{itemize}
\end{frame}

%21
\begin{frame}{Bubble sort}
  \begin{exampleblock}{\textattachfile{bubble3.c}{bubble3.c}}
    \footnotesize
    \lstinputlisting[style=c,linerange={15-29},firstnumber=15]{bubble3.c}
  \end{exampleblock}
\end{frame}

%22
\begin{frame}{Pointers}
  Pointer arithmetics: similarly to integers, operations can be evaluated with pointers
  \begin{itemize}
    \item A pointer can be increased and decreased $\to$ the real increase/decrease of the address is the size of the data
    \item Pointers can be compared (relations)
    \item addressOfAnArrayElement = \\ \qquad baseAddressOfTheArray + index*sizeof(typeOfArray)
    \item \texttt{array[index]} $\equiv$ \texttt{*(array + index)}
    \item The \texttt{void*} pointer is a special one: the size of the object it points to is unknown
    \item The difference of pointers addressing elements of the same array can be calculated
  \end{itemize}
\end{frame}

%23
\begin{frame}[fragile]{Pointers}
\begin{exampleblock}{\textattachfile{pointers2.c}{pointers2.c}}
    \footnotesize
    \lstinputlisting[style=c,linerange={4-9},firstnumber=4]{pointers2.c}
  \end{exampleblock}
  \begin{block}{Output}
    \begin{verbatim}
Value (address) of the 1st element:	100 (0x7ffd290eb7dc)
Value (address) of the 2nd element:	200 (0x7ffd290eb7e0)
Value (address) of the 3rd element:	300 (0x7ffd290eb7e4)    
\end{verbatim}
  \end{block}
\end{frame}

%24
\begin{frame}{Bubble sort}
  \begin{exampleblock}{\textattachfile{bubble4.c}{bubble4.c}}
    \lstinputlisting[style=c,linerange={15-20},firstnumber=15]{bubble4.c}
  \end{exampleblock}
\end{frame}

%25
\begin{frame}{Substitution of substrings}
  Task:
  \begin{itemize}
    \item Create a \emph{new} string based on an \emph{old} one by replacing a specific substring with something else!
    \item Eg. ``\emph{Jane} cooks, \emph{Jane} bakes, \emph{Jane} does the washing up'' $\to$ ``\emph{Emily} cooks, \emph{Emily} bakes, \emph{Emily} does the washing up''
  \end{itemize}
  Solution:
  \begin{enumerate}
    \item Search for the first occurrence of \emph{Jane} in the \emph{old} string
    \item Append everything in front of it to the end of the initially empty \emph{new} string
    \item Next, append \emph{Emily} to \emph{new}
    \item Search for the next occurrance of \emph{Jane}, then repeat steps 2 and 3 until we find all occurrences of \emph{Jane}
    \item Append the remaining characters after the last occurrence of \emph{Jane} to \emph{new}
  \end{enumerate}
\end{frame}

%26
\begin{frame}{Substitution of substrings}
  What do we need?
  \begin{itemize}
    \small
    \item \texttt{size\_t strlen(const char *s);} \\
      Provides the length of \texttt{s} excluding the terminating \texttt{'\textbackslash0'} character
    \item \texttt{char *strstr(const char *haystack, const char *needle);} \\
      Returns the first occurrence of \texttt{needle} in \texttt{haystack}, or a \texttt{NULL} pointer if it is not found
    \item \texttt{char *strcat(char *dest, const char *src);} \\
      \texttt{char *str\kiemel{n}cat(char *dest, const char *src, size\_t n);} \\
      Appends \texttt{src} to the end of \texttt{dest}, then puts the terminating \texttt{'\textbackslash0'} appropriately at the end of the string \\
      \texttt{strncat()} appends at most \texttt{n} characters to the end of \texttt{dest}\\
    \item \texttt{size\_t} is generally an \texttt{unsigned int}
    \item There must be sufficient (\texttt{strlen(dest)+strlen(src)+1} or \texttt{strlen(dest)+n+1}) space starting from \texttt{dest}
  \end{itemize}
\end{frame}

%27
\begin{frame}{Substitution of substrings}
  \begin{exampleblock}{\textattachfile{names1.c}{names1.c}}
    \scriptsize
    \lstinputlisting[style=c,linerange={8-25},firstnumber=8]{names1.c}
  \end{exampleblock}
\end{frame}

%28
\begin{frame}{Substitution of substrings}
  \scriptsize
  \begin{exampleblock}{\textattachfile{names2.c}{Determining length}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={8-12},firstnumber=8]{names2.c}
    \vspace{-.3cm}
  \end{exampleblock}
  \scriptsize
  \begin{exampleblock}{\textattachfile{names2.c}{Looking for the \emph{needle} in the \emph{haystack}}}
    \scriptsize
    \vspace{-.3cm}
    \lstinputlisting[style=c,linerange={14-23},firstnumber=14]{names2.c}
    \vspace{-.3cm}
  \end{exampleblock}
\end{frame}

%29
\begin{frame}{Substitution of substrings}
  \begin{exampleblock}{\textattachfile{names2.c}{Appending at most \emph{n} characters}}
    \scriptsize
    \lstinputlisting[style=c,linerange={25-38},numbers=left,firstnumber=25]{names2.c}
  \end{exampleblock}
\end{frame}

%30
\begin{frame}{Substitution of substrings}
  \begin{exampleblock}{\textattachfile{names2.c}{Merging strings}}
    \footnotesize
    \lstinputlisting[style=c,linerange={40-48},numbers=left,firstnumber=39]{names2.c}
  \end{exampleblock}
\end{frame}

%31
\begin{frame}{Determining vowels and consonants}
  Task:
  \begin{itemize}
    \small
    \item[] Determine from all the letters of a string whether they are vowels or consonants.
  \end{itemize}
  Solution:
  \begin{enumerate}
    \small
    \item Define a string of vowels (because there are much more consonants)
    \item Check all the characters of the string and if the current one is a letter look for it among vowels
    \item If it is found somewhere $\to$ vowel, else $\to$ consonant
  \end{enumerate}
  What do we need?
  \begin{itemize}
    \small
    \item \texttt{char *strchr(const char *s, int c);} \\
      Returns the address of the \kiemel{1st} occurrence of \texttt{c} in \texttt{s}, or \texttt{NULL} if it is not found \\
      It works even if \texttt{c=='\textbackslash0'}
    \item \texttt{char *str\kiemel{r}chr(const char *s, int c);} \\
      Like \texttt{strchr()}, but returns the address of the \kiemel{last} occurrence
  \end{itemize}
\end{frame}

%32
\begin{frame}{Determining vowels and consonants}
  \begin{exampleblock}{\textattachfile{vowel1.c}{vowel1.c}}
    \scriptsize
    \lstinputlisting[style=c,linerange={5-18},firstnumber=5]{vowel1.c}
  \end{exampleblock}
\end{frame}

%33
\begin{frame}{Determining vowels and consonants}
  \begin{exampleblock}{\textattachfile{vowel2.c}{Looking for a character in a string}}
    \lstinputlisting[style=c,linerange={5-9},firstnumber=5]{vowel2.c}
  \end{exampleblock}
  \vfill
  Remark: \texttt{printf} is too complex (slow) to print a sole character
  \begin{itemize}
    \item \texttt{int putchar(int c);} \\
      Puts character \texttt{c} to the standard output \\
      Return value: the printed character or \texttt{EOF} in case of an error
  \end{itemize}
\end{frame}

%34
\begin{frame}{Determining vowels and consonants}
  \begin{exampleblock}{\textattachfile{vowel2.c}{vowel2.c}}
    \scriptsize
    \lstinputlisting[style=c,linerange={11-24},firstnumber=11]{vowel2.c}
  \end{exampleblock}
\end{frame}

%35
\begin{frame}{Comparing names}
  Task:
  \begin{itemize}
    \item[] Read two names and determine their order according to the alphabet.
  \end{itemize}
  What do we need?
  \begin{itemize}
    \item \texttt{int strcmp(const char *s1, const char *s2);}\\
      \texttt{int str\kiemel{n}cmp(const char *s1, const char *s2, size\_t n);}\\
      They compare parameters \texttt{s1} and \texttt{s2} interpreted as sequences of \texttt{unsigned char}s. The return value is
      \begin{itemize}
        \scriptsize
        \item negative, if \texttt{*s1 < *s2},
        \item positive, if \texttt{*s1 > *s2},
        \item zero otherwise.
      \end{itemize}
      \texttt{strncmp()} carries out the comparison at most with the first \texttt{n} characters
    \item Does it have any sense to directly compare \texttt{s1} and \texttt{s2} with relational operators?
  \end{itemize}
\end{frame}

%36
\begin{frame}{Comparing names}
  \begin{exampleblock}{\textattachfile{compare1.c}{compare1.c}}
    \scriptsize
    \lstinputlisting[style=c,linerange={6-20},firstnumber=6]{compare1.c}
  \end{exampleblock}
\end{frame}

%37
\begin{frame}{Comparing names}
  \begin{exampleblock}{\textattachfile{compare2.c}{Comparing strings}}
    \scriptsize
    \lstinputlisting[style=c,linerange={5-8},firstnumber=5]{compare2.c}
  \end{exampleblock}
  Problem: \texttt{scanf} cannot read a string containing white spaces\\
  Possible solutions:
  \begin{itemize}
    \item \texttt{char *gets(char *s);} \\
      Reads a line from standard input until \emph{new line} or \texttt{EOF} arrives. It does not store the new line character itself. No buffer overrun protection, \kiemel{deprecated}.
    \item \texttt{char *fgets(char *s, int size, FILE *stream);} \\
      Reads a line from \texttt{stream} and stores at most \texttt{size}-1 characters until \emph{new line} or \texttt{EOF} 
arrives. It stores the new line character as well.
  \end{itemize}
\end{frame}

%38
\begin{frame}{Reading lines}
  \begin{exampleblock}{\textattachfile{compare3.c}{Reading with \texttt{gets}}}
    \footnotesize
    \lstinputlisting[style=c,linerange={10-11},firstnumber=10]{compare3.c}
  \end{exampleblock}
  \begin{exampleblock}{\textattachfile{compare4.c}{Reading with \texttt{fgets}}}
    \footnotesize
    \lstinputlisting[style=c,linerange={10-16},firstnumber=10]{compare4.c}
  \end{exampleblock}
\end{frame}

%39
\begin{frame}{Reading lines}
  \footnotesize
  Combination of good properties: \texttt{sze\_getline} (\kiemel{Be careful!} Some libraries already contain the function \texttt{getline} and that may cause a name collision. To prevent this, the prefix \texttt{sze\_} was applied.)
  \begin{itemize}
    \scriptsize
    \item Never reads more characters than can be stored in the available space
    \item Does not store the \emph{new line} character
    \item Clears the character buffer before next reading
  \end{itemize}
  \begin{exampleblock}{\textattachfile{compare5.c}{Reading with own \texttt{getline} function}}
    \scriptsize
    \lstinputlisting[style=c,linerange={7-14},firstnumber=7]{compare5.c}
    \lstinputlisting[style=c,linerange={20-21},firstnumber=20]{compare5.c}
  \end{exampleblock}
  \begin{itemize}
    \item \texttt{int getchar(void);} \\
      Reads a single character from the standard input
  \end{itemize}
\end{frame}

%40
\begin{frame}{Reading lines}
  \scriptsize
  Task:
  \begin{itemize}
    \item[] Write a program that reads names from the standard input until EOF or an empty line arrives.
Determine and print the longest name!
  \end{itemize}
  \begin{exampleblock}{\textattachfile{longest1.c}{longest1.c}}
    \fontsize{8}{9} \selectfont
    \lstinputlisting[style=c,linerange={15-32},firstnumber=15]{longest1.c}
  \end{exampleblock}
\end{frame}

%41
\begin{frame}{Reading lines}
  \footnotesize
  \begin{itemize}
    \item \texttt{char *strcpy(char *dest, const char *src);} \\
      \texttt{char *str\kiemel{n}cpy(char *dest, const char *src, size\_t n);}\\
      Copying characters from \texttt{src} to \texttt{dest}\\
      They return the address of the result (\texttt{dest}) \\
      \texttt{strncpy()} copies at most \texttt{n} characters. If \texttt{src} is shorter then \texttt{n} it stores even the terminating \texttt{'\textbackslash 0'} as well \\
      They \kiemel{do not check} that the result fits at \texttt{dest} or not!
  \end{itemize}
  \begin{exampleblock}{\textattachfile{longest2.c}{Copying strings}}
    \lstinputlisting[style=c,linerange={5-10},numbers=left,firstnumber=5]{longest2.c}
  \end{exampleblock}
\end{frame}

%42
\begin{frame}[fragile]{Tokenizing a string}
  Task:
  \begin{itemize}
    \item Determine the key--value pairs of an URL query string.
    \item \texttt{http://it.sze.hu/index.php?\kiemel{tart}=\kiemelZ{hirek}\&\kiemel{old}=\kiemelZ{2}}
  \end{itemize}
  What do we need?
  \begin{itemize}
    \item \texttt{char *strtok(char *str, const char *delim);} \\
      If \texttt{str} is not \texttt{NULL} it returns the first token found in it. Tokens may be separated by any of the characters in \texttt{delim}. In order to find the further tokens \texttt{str} must be \texttt{NULL}. If no more tokens \texttt{strtok} returns \texttt{NULL}. Terminating null characters are inserted in \texttt{str} during searcing!
  \end{itemize}
\end{frame}

%43
\begin{frame}{Tokenizing a string}
  \scriptsize
  \begin{exampleblock}{\textattachfile{keyvalue1.c}{keyvalue1.c}}
    \lstinputlisting[style=c,linerange={4-19},firstnumber=4]{keyvalue1.c}
  \end{exampleblock}
\end{frame}

%44
\begin{frame}{Generating random numbers}
  \begin{itemize}
    \item Generating \hiv{\href{https://en.wikipedia.org/wiki/Pseudorandom_number_generator}{pseudo-random numbers}} (PseudoRandom Number Generator, PRNG)
    \item Required header: \texttt{stdlib.h}
    \item Initial state: \texttt{void srand(unsigned int seed);}, where \texttt{seed} initializes the generator
    \item Random numbers: $0 \leq$ \texttt{int rand(void);} $\leq$ \texttt{RAND\_MAX}
  \end{itemize}
  Examples:
   \begin{itemize}
     \item \texttt{x = (double)rand()/RAND\_MAX} ahol $\left\{x|x\in\mathbb{R}, 0 \leq x \leq 1 \right\}$
     \item \texttt{x = MIN + rand()\%(MAX-MIN+1)} ahol $\left\{x|x\in\mathbb{Z}, MIN \leq x \leq MAX \right\}$
   \end{itemize}
\end{frame}

%45
\begin{frame}{Generating random numbers}
  Problem: same \texttt{seed} $\to$ same number sequences\\
  Solution:
  \begin{itemize}
    \item \texttt{seed} must be different at every program start $\to$ current time
    \item Required header: \texttt{time.h}
    \item \texttt{time\_t time(time\_t *t);}
    \item Return value: expressed with type \texttt{time\_t} (\texttt{long}); seconds elapsed since ``the epoch'', 1970-01-01 00:00:00 +0000 (UTC). It also stores it at \texttt{t} except that is \texttt{NULL}.
  \end{itemize}
  \vfill
  \tiny
  The C++ language has \hiv{\href{http://www.cplusplus.com/reference/random/}{much more sophistacated capabilities}}.\\
  \hiv{\href{http://www.cplusplus.com/faq/beginners/random-numbers/}{Further information}} regarding generating random numbers.
\end{frame}

%46
\begin{frame}{Generating random numbers}
  \begin{exampleblock}{\textattachfile{guess.c}{guess.c}}
    \scriptsize
    \lstinputlisting[style=c]{guess.c}
  \end{exampleblock}
\end{frame}

\end{document}
